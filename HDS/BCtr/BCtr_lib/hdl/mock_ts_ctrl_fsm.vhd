-- VHDL Entity BCtr_lib.mock_ts_ctrl.interface
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 16:42:16 10/30/2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
LIBRARY std;
USE std.textio;

ENTITY mock_ts_ctrl IS
  PORT( 
    clk    : IN     std_logic;
    rdreq  : IN     std_logic;
    rst    : IN     std_logic;
    start  : IN     std_logic;
    stop   : IN     std_logic;
    tsdata : IN     std_logic_vector (31 DOWNTO 0);
    tsen   : IN     std_logic;
    RE     : OUT    std_logic;
    en     : OUT    std_logic;
    rdata  : OUT    std_logic_vector (7 DOWNTO 0)
  );

-- Declarations

END ENTITY mock_ts_ctrl ;

--
-- VHDL Architecture BCtr_lib.mock_ts_ctrl.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 16:42:15 10/30/2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
--  Machine             :  "csm", synchronous
--  Encoding            :  none
--  Style               :  case, 3 processes
--  Clock               :  "clk", rising 
--  Synchronous Reset   :  "rst", synchronous, active high
--  State variable type :  [auto]
--  Default state assignment disabled
--  State actions registered on current state
--  
--   SIGNAL  MODE    DEFAULT  RESET            SCHEME 
--   en      OUT              '0'              CLKD   
--   rdata   OUT              (others => '0')  CLKD   
--   RE      OUT              '1'              CLKD   
--   rdreg   LOCAL            (others => '0')  CLKD   
--   
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
LIBRARY std;
USE std.textio;
 
ARCHITECTURE fsm OF mock_ts_ctrl IS

  -- Architecture Declarations
  SIGNAL rdreg : std_logic_vector(31 DOWNTO 0);  

  TYPE STATE_TYPE IS (
    s0,
    s1,
    s2,
    s3,
    s4,
    s5,
    s6,
    s7,
    s8,
    s9,
    s10
  );
 
  -- Declare current and next state signals
  SIGNAL current_state : STATE_TYPE;
  SIGNAL next_state : STATE_TYPE;

  -- Declare Wait State internal signals
  SIGNAL csm_timer : std_logic_vector(23 DOWNTO 0);
  SIGNAL csm_next_timer : std_logic_vector(23 DOWNTO 0);
  SIGNAL csm_timeout : std_logic;
  SIGNAL csm_to_s9 : std_logic;

  -- Declare any pre-registered internal signals
  SIGNAL RE_cld : std_logic ;
  SIGNAL en_cld : std_logic ;
  SIGNAL rdata_cld : std_logic_vector (7 DOWNTO 0);

BEGIN

  -----------------------------------------------------------------
  clocked_proc : PROCESS ( 
    clk
  )
  -----------------------------------------------------------------
  BEGIN
    IF (clk'EVENT AND clk = '1') THEN
      IF (rst = '1') THEN
        current_state <= s0;
        csm_timer <= (OTHERS => '0');
        -- Default Reset Values
        RE_cld <= '1';
        en_cld <= '0';
        rdata_cld <= (others => '0');
        rdreg <= (others => '0');
      ELSE
        current_state <= next_state;
        csm_timer <= csm_next_timer;

        -- Combined Actions
        CASE current_state IS
          WHEN s0 => 
            en_cld <= '0';
          WHEN s1 => 
            rdreg <= tsdata;
            en_cld <= '1';
          WHEN s2 => 
            rdata_cld <= rdreg(31 downto 24);
            RE_cld <= '1';
          WHEN s4 => 
            rdata_cld <= rdreg(23 downto 16);
            RE_cld <= '1';
          WHEN s6 => 
            rdata_cld <= rdreg(15 downto 8);
            RE_cld <= '1';
          WHEN s8 => 
            rdata_cld <= rdreg(7 downto 0);
            RE_cld <= '1';
            IF (rdreq /= '1' AND stop = '1') THEN 
              en_cld <= '0';
            END IF;
          WHEN OTHERS =>
            NULL;
        END CASE;
      END IF;
    END IF;
  END PROCESS clocked_proc;
 
  -----------------------------------------------------------------
  nextstate_proc : PROCESS ( 
    csm_timeout,
    current_state,
    rdreq,
    start,
    stop,
    tsen
  )
  -----------------------------------------------------------------
  BEGIN
    -- Default assignments to Wait State entry flags
    csm_to_s9 <= '0';
    CASE current_state IS
      WHEN s0 => 
        IF (start = '1' AND tsen = '1') THEN 
          next_state <= s1;
        ELSE
          next_state <= s0;
        END IF;
      WHEN s1 => 
        IF (start /= '1') THEN 
          next_state <= s10;
        ELSE
          next_state <= s1;
        END IF;
      WHEN s2 => 
        IF (rdreq /= '1') THEN 
          next_state <= s3;
        ELSE
          next_state <= s2;
        END IF;
      WHEN s3 => 
        IF (rdreq ='1') THEN 
          next_state <= s4;
        ELSE
          next_state <= s3;
        END IF;
      WHEN s4 => 
        IF (rdreq /= '1') THEN 
          next_state <= s5;
        ELSE
          next_state <= s4;
        END IF;
      WHEN s5 => 
        IF (rdreq ='1') THEN 
          next_state <= s6;
        ELSE
          next_state <= s5;
        END IF;
      WHEN s6 => 
        IF (rdreq /= '1') THEN 
          next_state <= s7;
        ELSE
          next_state <= s6;
        END IF;
      WHEN s7 => 
        IF (rdreq ='1') THEN 
          next_state <= s8;
        ELSE
          next_state <= s7;
        END IF;
      WHEN s8 => 
        IF (rdreq /= '1' AND stop = '1') THEN 
          next_state <= s9;
          csm_to_s9 <= '1';
        ELSE
          next_state <= s8;
        END IF;
      WHEN s9 => 
        IF (csm_timeout = '1') THEN 
          next_state <= s0;
        ELSE
          next_state <= s9;
        END IF;
      WHEN s10 => 
        IF (rdreq ='1' and tsen = '1') THEN 
          next_state <= s2;
        ELSE
          next_state <= s10;
        END IF;
      WHEN OTHERS =>
        next_state <= s0;
    END CASE;
  END PROCESS nextstate_proc;
 
  -----------------------------------------------------------------
  csm_wait_combo_proc: PROCESS (
    csm_timer,
    csm_to_s9
  )
  -----------------------------------------------------------------
  VARIABLE csm_temp_timeout : std_logic;
  BEGIN
    IF (unsigned(csm_timer) = 0) THEN
      csm_temp_timeout := '1';
    ELSE
      csm_temp_timeout := '0';
    END IF;

    IF (csm_to_s9 = '1') THEN
      csm_next_timer <= "110010101111000100011111"; -- no cycles(13300000)-1=13299999
    ELSE
      IF (csm_temp_timeout = '1') THEN
        csm_next_timer <= (OTHERS=>'0');
      ELSE
        csm_next_timer <= std_logic_vector(unsigned(csm_timer) - 1);
      END IF;
    END IF;
    csm_timeout <= csm_temp_timeout;
  END PROCESS csm_wait_combo_proc;

  -- Concurrent Statements
  -- Clocked output assignments
  RE <= RE_cld;
  en <= en_cld;
  rdata <= rdata_cld;
END ARCHITECTURE fsm;

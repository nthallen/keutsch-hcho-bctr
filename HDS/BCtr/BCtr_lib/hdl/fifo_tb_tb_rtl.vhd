--
-- VHDL Test Bench BCtr_lib.FIFO_tb.FIFO_tester
--
-- Created:
--          by - . (NORT-XPS14)
--          at - 19:00:00 12/31/69
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1b (Build 2)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;


ENTITY FIFO_tb IS
   GENERIC (
      FIFO_WIDTH      : integer range 32 downto 1 := 16;
      FIFO_ADDR_WIDTH : integer range 10 downto 1 := 4
   );
END FIFO_tb;


LIBRARY BCtr_lib;
USE BCtr_lib.ALL;


ARCHITECTURE rtl OF FIFO_tb IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL WData : std_logic_vector(FIFO_WIDTH-1 DOWNTO 0);
   SIGNAL WE    : std_logic;
   SIGNAL RE    : std_logic;
   SIGNAL Clk   : std_ulogic;
   SIGNAL Rst   : std_logic;
   SIGNAL RData : std_logic_vector(FIFO_WIDTH-1 DOWNTO 0);
   SIGNAL Empty : std_logic;
   SIGNAL Full  : std_logic;
   SIGNAL SimDone : std_logic;
   SIGNAL WCtr, RCtr : std_logic_vector(FIFO_WIDTH-1 DOWNTO 0);


   -- Component declarations
   COMPONENT FIFO
      GENERIC (
         FIFO_WIDTH      : integer range 16 downto 1 := 1;
         FIFO_ADDR_WIDTH : integer range 10 downto 1 := 8
      );
      PORT (
         WData : IN     std_logic_vector(FIFO_WIDTH-1 DOWNTO 0);
         WE    : IN     std_logic;
         RE    : IN     std_logic;
         Clk   : IN     std_ulogic;
         Rst   : IN     std_logic;
         RData : OUT    std_logic_vector(FIFO_WIDTH-1 DOWNTO 0);
         Empty : OUT    std_logic;
         Full  : OUT    std_logic
      );
   END COMPONENT;

   -- embedded configurations
   -- pragma synthesis_off
   FOR U_0 : FIFO USE ENTITY BCtr_lib.FIFO;
   -- pragma synthesis_on

BEGIN

   U_0 : FIFO
      GENERIC MAP (
         FIFO_WIDTH      => FIFO_WIDTH,
         FIFO_ADDR_WIDTH => FIFO_ADDR_WIDTH
      )
      PORT MAP (
         WData => WData,
         WE    => WE,
         RE    => RE,
         Clk   => Clk,
         Rst   => Rst,
         RData => RData,
         Empty => Empty,
         Full  => Full
      );
      
  f100m_clk : Process is
  Begin
    Clk <= '0';
    -- pragma synthesis_off
    wait for 20 ns;
    while SimDone = '0' loop
      Clk <= '1';
      wait for 5 ns;
      Clk <= '0';
      wait for 5 ns;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;


  test_proc: Process is
    procedure cycle is
    begin
      wait until Clk'Event and Clk = '1';
      wait for 2 ns;
      return;
    end procedure cycle;

    procedure write_int is
    begin
      WData <= WCtr;
      WCtr <= WCtr+1;
      WE <= '1';
      assert Full = '0' report "Attempted write while Full" severity error;
      return;
    end procedure write_int;
    
    procedure write is
    begin
      write_int;
      RE <= '0';
      cycle;
      assert Empty = '0' report "Empty after write" severity error;
      return;
    end procedure write;
      
    
    procedure read_int is
    begin
      RE <= '1';
      assert Empty = '0' report "Attempted read while Empty" severity error;
      if RData /= RCtr then
        report "Unexpected skip in read values" severity error;
        RCtr <= RData+1;
      else
        RCtr <= RCtr+1;
      end if;
      return;
    end procedure read_int;
    
    procedure read is
    begin
      read_int;
      WE <= '0';
      cycle;
      assert Full = '0' report "Full after read" severity error;
      return;
    end procedure read;
    
    procedure space is
    begin
      WE <= '0';
      RE <= '0';
      cycle;
      return;
    end procedure space;
    
    procedure readwrite is
    begin
      read_int;
      write_int;
      cycle;
      assert Empty = '0' report "Empty after write" severity error;
      assert Full = '0' report "Full after read" severity error;
      return;
    end procedure readwrite;
    
    constant fifo_size : integer := 2**FIFO_ADDR_WIDTH;
  Begin
    SimDone <= '0';
    Rst <= '1';
    WCtr <= (others => '0');
    RCtr <= (others => '0');
    -- pragma synthesis_off
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    rst <= '0';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    assert Empty = '1' report "Not empty after reset" severity error;
    assert Full = '0' report "Full on reset" severity error;

    -- Test basic writes and reads with time between exceeding FIFO size
    for i in 1 to fifo_size+3 loop
      write;
      space;
      read;
      space;
    end loop;
    assert Empty = '1' report "Not Empty after test 1" severity error;
    
    -- Test basic writes and reads without time between
    for i in 1 to fifo_size loop
      write;
    end loop;
    assert Empty = '0' report "Empty despite being full" severity error;
    assert Full = '1' report "Not full after full write" severity error;
    for i in 1 to fifo_size loop
      read;
    end loop;
    assert Empty = '1' report "Not empty after test 2" severity error;
    assert Full = '0' report "Full despite being Empty" severity error;
    
    -- Test readwrite without time between exceeding FIFO size
    write;
    for i in 1 to fifo_size+3 loop
      readwrite;
    end loop;
    read;
    assert Empty = '1' report "Not Empty after test 3" severity error;
    assert Full = '0' report "Full despite being Empty" severity error;
    
    -- Verify that read on empty does not confuse count
    RE <= '1';
    cycle;
    assert Empty = '1' report "Not Empty after read on Empty" severity error;
    write;
    assert Empty = '0' report "Empty after write" severity error;
    read; -- Should not complain about a skip or anything
    assert Empty = '1' report "Not Empty after read on empty verification" severity error;
    
    -- Verify that write on full does not advance
    for i in 1 to fifo_size loop
      write;
    end loop;
    assert Full = '1' report "Not full after full write" severity error;
    WE <= '1';
    cycle;
    assert Full = '1' report "Not still full after write on Full" severity error;
    for i in 1 to fifo_size loop
      read;
    end loop;
    assert Empty = '1' report "Not Empty after read from full" severity error;
    write;
    read;
    assert Empty = '1' report "Not Empty after read from full" severity error;
    space;
    
    SimDone <= '1';
    wait;
   -- pragma synthesis_on
  End Process;
    

END rtl;
--
-- VHDL Test Bench BCtr_lib.BCtrCtrl_tb.BCtrCtrl_tester
--
-- Created:
--          by - . (NORT-XPS14)
--          at - 19:00:00 12/31/69
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1b (Build 2)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;


ENTITY BCtrCtrl_tb IS
   GENERIC (
      FIFO_ADDR_WIDTH : integer range 10 downto 1 := 8
   );
END BCtrCtrl_tb;


LIBRARY BCtr_lib;
USE BCtr_lib.ALL;


ARCHITECTURE rtl OF BCtrCtrl_tb IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL Empty1    : std_logic;
   SIGNAL Empty2    : std_logic;
   SIGNAL En        : std_logic;
   SIGNAL Full1     : std_logic;
   SIGNAL NA        : std_logic_vector(15 DOWNTO 0);
   SIGNAL NC        : std_logic_vector(15 DOWNTO 0);
   SIGNAL NB        : std_logic_vector(FIFO_ADDR_WIDTH-1 DOWNTO 0);
   SIGNAL TrigSeen  : std_logic;
   SIGNAL clk       : std_logic;
   SIGNAL rst       : std_logic;
   SIGNAL CntEn     : std_logic;
   SIGNAL DRdy      : std_logic;
   SIGNAL RE1       : std_logic;
   SIGNAL TrigArm   : std_logic;
   SIGNAL TrigClr   : std_logic;
   SIGNAL TrigOE    : std_logic;
   SIGNAL WE1       : std_logic;
   SIGNAL WE2       : std_logic;
   SIGNAL first_col : std_logic;
   SIGNAL first_row : std_logic;
   SIGNAL NSkipped  : std_logic_vector(15 DOWNTO 0);
   SIGNAL SimDone   : std_logic;


   -- Component declarations
   COMPONENT BCtrCtrl
      GENERIC (
         FIFO_ADDR_WIDTH : integer range 10 downto 1 := 8
      );
      PORT (
         Empty1    : IN     std_logic;
         Empty2    : IN     std_logic;
         En        : IN     std_logic;
         Full1     : IN     std_logic;
         NA        : IN     std_logic_vector(15 DOWNTO 0);
         NC        : IN     std_logic_vector(15 DOWNTO 0);
         NB        : IN     std_logic_vector(FIFO_ADDR_WIDTH-1 DOWNTO 0);
         TrigSeen  : IN     std_logic;
         clk       : IN     std_logic;
         rst       : IN     std_logic;
         CntEn     : OUT    std_logic;
         DRdy      : OUT    std_logic;
         RE1       : OUT    std_logic;
         TrigArm   : OUT    std_logic;
         TrigClr   : OUT    std_logic;
         TrigOE    : OUT    std_logic;
         WE1       : OUT    std_logic;
         WE2       : OUT    std_logic;
         first_col : OUT    std_logic;
         first_row : OUT    std_logic;
         NSkipped  : OUT    std_logic_vector (15 DOWNTO 0)
      );
   END COMPONENT;

   -- embedded configurations
   -- pragma synthesis_off
   FOR U_0 : BCtrCtrl USE ENTITY BCtr_lib.BCtrCtrl;
   -- pragma synthesis_on

BEGIN

         U_0 : BCtrCtrl
            GENERIC MAP (
               FIFO_ADDR_WIDTH => FIFO_ADDR_WIDTH
            )
            PORT MAP (
               Empty1    => Empty1,
               Empty2    => Empty2,
               En        => En,
               Full1     => Full1,
               NA        => NA,
               NC        => NC,
               NB        => NB,
               TrigSeen  => TrigSeen,
               clk       => clk,
               rst       => rst,
               CntEn     => CntEn,
               DRdy      => DRdy,
               RE1       => RE1,
               TrigArm   => TrigArm,
               TrigClr   => TrigClr,
               TrigOE    => TrigOE,
               WE1       => WE1,
               WE2       => WE2,
               first_col => first_col,
               first_row => first_row,
               NSkipped  => NSkipped
            );

      
  f100m_clk : Process is
  Begin
    clk <= '0';
    -- pragma synthesis_off
    wait for 20 ns;
    while SimDone = '0' loop
      clk <= '1';
      wait for 5 ns;
      clk <= '0';
      wait for 5 ns;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;

  test_proc: Process is
  Begin
    SimDone <= '0';
    NA <= X"0004";
    NB <= X"02";
    NC <= X"0001";
    TrigSeen <= '0';
    En <= '0';
    Full1 <= '0';
    Empty1 <= '1';
    Empty2 <= '1';
    
    rst <= '1';
    -- pragma synthesis_off
    wait until clk'Event and clk = '1';
    rst <= '0';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    
    assert TrigArm = '0' report "Trigger armed during reset" severity error;
    assert TrigOE = '1' report "Trigger OE not set" severity error;
    assert TrigClr = '1' report "Trigger not cleared during reset" severity error;
    
    En <= '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    wait for 2 ns;

    assert TrigArm = '1' report "Trigger not armed after enable" severity error;
    assert TrigOE = '1' report "Trigger OE not set after enable" severity error;
    assert TrigClr = '0' report "Trigger cleared after enable" severity error;
    
    -- Report 1: Do one full report without intervention
    -- Report 1 Trigger 1 of 2
    TrigSeen <= '1';
    wait until TrigClr = '1';
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    -- Report 1 Trigger 2 of 2
    wait until TrigClr = '0' AND TrigArm = '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    TrigSeen <= '1';
    wait until TrigClr = '1';
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    wait until WE2 = '1' for 50 ns;
    assert WE2 = '1' report "WE2 not seen" severity error;
    wait until clk'Event and clk = '1';
    Empty2 <= '0';
    wait until DRdy = '1' for 200 ns;
    assert DRdy = '1' report "DRdy not seen for R1" severity error;
    -- Simulate reading data
    for i in 1 to 4 loop
      wait until clk'Event and clk = '1';
    end loop;
    Empty2 <= '1';
    
    -- Report 2 Trigger 1 of 2
    if TrigClr = '1' OR TrigArm = '0' then
      wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
      assert TrigClr = '0' AND TrigArm = '1'
         report "TrigClr/Arm not seen for R2T1" severity error;
    end if;
    wait until clk'Event and clk = '1';
    TrigSeen <= '1';
    wait until TrigClr = '1' for 100 ns;
    assert TrigClr = '1' report "TrigClr not seen for R2T1" severity error;
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    -- Report 2 Trigger 2 of 2
    wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
    assert TrigClr = '0' AND TrigArm = '1'
      report "TrigClr/Arm not seen for R2T2" severity error;
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    TrigSeen <= '1';
    wait until TrigClr = '1' for 200 ns;
    assert TrigClr = '1' report "TrigClr not seen for R2T2" severity error;
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    wait until WE2 = '1';
    assert WE2 = '1' report "WE2 not seen for R2T2" severity error;
    wait until clk'Event and clk = '1';
    Empty2 <= '0';
    wait until DRdy = '1' for 200 ns;
    assert DRdy = '1' report "DRdy not seen for R2" severity error;
    -- Delay reading to observe delay in Report 3

    if TrigClr = '1' OR TrigArm = '0' then
      wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
      assert TrigClr = '0' AND TrigArm = '1'
         report "TrigClr/Arm not seen for R2T2" severity error;
    end if;
    wait until clk'Event and clk = '1';
     
    -- Report 3 Trigger 1 of 2
    if TrigClr = '1' OR TrigArm = '0' then
      wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
      assert TrigClr = '0' AND TrigArm = '1'
         report "TrigClr/Arm not seen for R3T1" severity error;
    end if;
    wait until clk'Event and clk = '1';
    TrigSeen <= '1';
    wait until TrigClr = '1' for 100 ns;
    assert TrigClr = '1' report "TrigClr not seen for R3T1" severity error;
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    -- Report 3 Trigger 2 of 2
    wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
    assert TrigClr = '1' OR TrigArm = '0'
      report "TrigClr/Arm seen for R3T2 without Empty2" severity error;
    wait until clk'Event and clk = '1';
    Empty2 <= '1';
    wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
    assert TrigClr = '0' AND TrigArm = '1'
      report "TrigClr/Arm not seen for R3T2 after Empty2" severity error;

    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    TrigSeen <= '1';
    wait until TrigClr = '1' for 200 ns;
    assert TrigClr = '1' report "TrigClr not seen for R3T2" severity error;
    wait until clk'Event and clk = '1';
    TrigSeen <= '0';
    
    wait until WE2 = '1';
    assert WE2 = '1' report "WE2 not seen for R3T2" severity error;
    wait until clk'Event and clk = '1';
    Empty2 <= '0';
    wait until DRdy = '1' for 200 ns;
    assert DRdy = '1' report "DRdy not seen for R3" severity error;
    -- Simulate reading data
    for i in 1 to 4 loop
      wait until clk'Event and clk = '1';
    end loop;
    Empty2 <= '1';

    if TrigClr = '1' OR TrigArm = '0' then
      wait until TrigClr = '0' AND TrigArm = '1' for 200 ns;
      assert TrigClr = '0' AND TrigArm = '1'
         report "TrigClr/Arm not seen for R3T2" severity error;
    end if;
    wait until clk'Event and clk = '1';
   
    En <= '0';
    wait until TrigClr = '1';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    
    
    SimDone <= '1';
    wait;
   -- pragma synthesis_on
  End Process;

END rtl;
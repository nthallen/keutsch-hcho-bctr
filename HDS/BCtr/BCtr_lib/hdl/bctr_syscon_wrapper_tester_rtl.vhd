--
-- VHDL Test Bench BCtr_lib.BCtr_syscon_wrapper_tester.BCtr_syscon_wrapper_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 12:41:33 01/19/2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
LIBRARY std;
USE std.textio.all;
USE ieee.std_logic_textio.all;


ENTITY BCtr_syscon_wrapper_tester IS
  GENERIC( 
    N_CHANNELS : integer range 4 downto 1       := 2;
    CTR_WIDTH  : integer range 32 downto 1      := 16;
    BIN_OPT    : integer range 10 downto 0      := 0; -- 0 to disable, 1,2,3 currently supported
    CTR_OPT    : integer := 1; -- 0 to skip basic counter test
    TEMP_OPT   : std_logic := '0'; -- Set true to run temp sensor tests
    AIO_OPT   : std_logic := '0'; -- Set true to run basic AIO tests
    DACSCAN_OPT : integer := 1; -- 0 to disable, 1 do all, 2 skip scan, online, offline
    SIM_LOOPS  : integer range 50 downto 0      := 10;
    NC         : integer range 2**24-1 downto 0 := 30000
  );
  PORT (
    Addr    : OUT    std_logic_vector(7 DOWNTO 0);
    Ctrl    : OUT    std_logic_vector(6 DOWNTO 0);
    Data_o  : OUT    std_logic_vector(15 DOWNTO 0);
    clk     : OUT    std_logic;
    Data_i  : IN     std_logic_vector(15 DOWNTO 0);
    Status  : IN     std_logic_vector(3 DOWNTO 0);
    en      : OUT    std_logic;
    rdata   : OUT    std_logic_vector (7 DOWNTO 0);
    WE      : IN     std_logic;
    rdreq   : IN     std_logic;
    start   : IN     std_logic;
    stop    : IN     std_logic;
    wdata   : IN     std_logic_vector (7 DOWNTO 0);
    RE      : INOUT  std_logic
  );
END ENTITY BCtr_syscon_wrapper_tester;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ARCHITECTURE rtl OF BCtr_syscon_wrapper_tester IS
  SIGNAL clk_int : std_logic;
  SIGNAL SimDone : std_logic;
  SIGNAL ReadResult : std_logic_vector(15 DOWNTO 0);
  SIGNAL BCtrStatus : std_logic_vector(15 DOWNTO 0);
  SIGNAL ctr_base : unsigned(7 DOWNTO 0);
  SIGNAL sp_updated : std_logic;
  SIGNAL prev_step : std_logic_vector(15 DOWNTO 0);
  SIGNAL BCtrReportCts : std_logic;
  CONSTANT temp_base : unsigned(7 DOWNTO 0) := to_unsigned(16#30#,8);
  CONSTANT aio_base : unsigned(7 DOWNTO 0) := to_unsigned(16#50#,8);
  -- CONSTANT NCU : unsigned(23 DOWNTO 0) := to_unsigned(NC,24);
  alias RdEn is Ctrl(0);
  alias WrEn is Ctrl(1);
  alias CS is Ctrl(2);
  alias CE is Ctrl(3);
  alias rst is Ctrl(4);
  alias arm is Ctrl(6);
  alias TickTock is Ctrl(5);
  alias Done is Status(0);
  alias Ack is Status(1);
  alias ExpIntr is Status(2);
  alias TwoSecondTO is Status(3);
BEGIN


  f100m_clk_int : Process is
  Begin
    clk_int <= '0';
    -- pragma synthesis_off
    wait for 2 ns;
    while SimDone = '0' loop
      clk_int <= '1';
      wait for 5 ns;
      clk_int <= '0';
      wait for 5 ns;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;
  
  clk <= clk_int;

  test_proc: Process is
    procedure sbwr(
        addr_in : IN unsigned(7 DOWNTO 0);
        data : IN std_logic_vector(15 DOWNTO 0);
        AckExpected : std_logic ) is
    begin
      Addr <= std_logic_vector(addr_in);
      Data_o <= data;
      -- pragma synthesis_off
      wait until clk_int'EVENT AND clk_int = '1';
      WrEn <= '1';
      for i in 1 to 8 loop
        wait until clk_int'EVENT AND clk_int = '1';
      end loop;
      if AckExpected = '1' then
        assert Ack = '1' report "Expected Ack" severity error;
      else
        assert Ack = '0' report "Expected no Ack" severity error;
      end if;
      WrEn <= '0';
      wait until clk_int'EVENT AND clk_int = '1';
      -- pragma synthesis_on
      return;
    end procedure sbwr;

    procedure sbrd( addr_in : unsigned (7 DOWNTO 0);
                    AckExpected : std_logic ) is
    begin
      Addr <= std_logic_vector(addr_in);
      -- pragma synthesis_off
      wait until clk_int'Event AND clk_int = '1';
      wait for 1 ns;
      RdEn <= '1';
      for i in 1 to 8 loop
        wait until clk_int'Event AND clk_int = '1';
      end loop;
      if AckExpected = '1' then
        assert Ack = '1' report "Expected Ack on read" severity error;
      else
        assert Ack = '0' report "Expected no Ack on read" severity error;
      end if;
      ReadResult <= Data_i;
      RdEn <= '0';
      wait for 125 ns;
      -- pragma synthesis_on
      return;
    end procedure sbrd;
    
    procedure check_read(addr_in : unsigned(7 DOWNTO 0);
                  expected : std_logic_vector(15 DOWNTO 0) ) is
      variable my_line : line;
    begin
      if ReadResult /= expected then
        write(my_line, now,right,12);
        write(my_line, string'(": sbrd("));
        hwrite(my_line, std_logic_vector(addr_in));
        write(my_line, string'(") Expected: "));
        hwrite(my_line, expected, RIGHT, 4);
        write(my_line, string'(" read: "));
        hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        writeline(output, my_line);
      end if;
      return;
    end procedure check_read;
    
    procedure check_cmds(cmds : std_logic_vector(15 DOWNTO 0)) IS
      variable my_line : line;
    begin
      sbrd(aio_base, '1');
      sbwr(aio_base, cmds, '1');
        write(my_line, now,right,12);
        write(my_line, string'(": htr cmd "));
        hwrite(my_line, cmds, RIGHT, 4);
        write(my_line, string'(" status "));
        hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        writeline(output, my_line);
      while ReadResult(5) /= cmds(5) OR ReadResult(9) /= cmds(9) loop
        sbrd(aio_base, '1');
      end loop;
      write(my_line, now,right,12);
      write(my_line, string'(": status "));
      hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
      writeline(output, my_line);
      return;
    end procedure check_cmds;
    
    procedure read_bctr_report(prompt : IN integer := 0; expected : IN integer := 0) IS
      -- prompt values:
      --   0: read report as soon as it's ready
      --   1: start reading report, then delay 
      --   2: Delay before starting transmission
      --   3: Delay a long time before doing anything (expired_3)
      -- expected values:
      --   0: Nothing expected
      --   1: Expected success with NWords > 4
      --   2: Expected NWords == 4
      variable line1 : line;
      variable line2 : line;
      variable IPnum : unsigned(5 downto 0);
      variable NTrig : unsigned(31 downto 0);
      variable row_cts : integer;
      variable NWords : unsigned(15 downto 0);
      variable LasPwr : unsigned(31 downto 0);
    begin
      sbrd(ctr_base,'1');
      while ReadResult(1) = '0' AND ReadResult(10) = '0' loop
        sbrd(ctr_base,'1');
      end loop;
      assert ReadResult(1) = '1'
        report "Expected DRdy with Expired" severity error;
      if prompt = 2 THEN
        wait for 21 ms;
      elsif prompt = 3 THEN
        wait for 41 ms;
      end if;
      sbrd(ctr_base+1,'1'); -- NWords
      NWords := unsigned(ReadResult);
      IF prompt = 1 THEN
        wait for 21 ms; -- Must be updated if testing IPS period changes
      END IF;
      IF expected = 1 THEN
        assert NWords > 4
        report "Expected NWords > 4" severity error;
      ELSIF expected = 2 THEN
        assert NWords = 4
        report "Expected NWords = 4" severity error;
      END IF;
      write(line1, now, right, 12);
      write(line1, string'(": NW:"));
      write(line1, to_integer(NWords));
      write(line1, string'(": "));
      -- assert NWords = 4 report "Expected NWords=4 after Expired" severity error;
      IF NWords > 0 THEN
        assert NWords >= 6 -- For late build 10 and up
          report "Expected NWords to be 0 or >= 6"
          severity error;
        NWords := NWords - 1;
        sbrd(ctr_base+2,'1');
        BCtrStatus <= ReadResult;
        IPnum := unsigned(ReadResult(5 DOWNTO 0));
        write(line1, string'("IP:"));
        write(line1, to_integer(IPnum));
        IF ReadResult(15) = '1' THEN
          write(line1, string'(" Expired"));
        END IF;
        IF ReadResult(14) = '1' THEN
          write(line1, string'("  PosOVF"));
        END IF;
        IF ReadResult(13) = '1' THEN
          write(line1, string'(" Chopping"));
        END IF;
        IF ReadResult(12) = '1' THEN
          write(line1, string'(" Offline"));
        END IF;
        IF ReadResult(11) = '1' THEN
          write(line1, string'(" Online"));
        END IF;
        IF ReadResult(10) = '1' THEN
          write(line1, string'(" Scanning"));
        END IF;
      END IF;
      IF NWords > 0 THEN
        NWords := NWords - 1;
        sbrd(ctr_base+2,'1');
        NTrig(15 DOWNTO 0) := unsigned(ReadResult);
        IF NWords > 0 THEN
          NWords := NWords - 1;
        END IF;
        sbrd(ctr_base+2,'1');
        NTrig(31 DOWNTO 16) := unsigned(ReadResult);
        write(line1, string'(" NT:"));
        write(line1, to_integer(NTrig));
      END IF;
      IF NWords > 0 THEN
        NWords := NWords - 1;
        sbrd(ctr_base+2,'1');
        write(line1, string'(" LV:"));
        write(line1, to_integer(unsigned(ReadResult)));
      END IF;
      IF NWords > 0 THEN
        NWords := NWords - 2;
        sbrd(ctr_base+2,'1');
        LasPwr(15 downto 0) := unsigned(ReadResult);
        sbrd(ctr_base+2,'1');
        LasPwr(31 downto 16) := unsigned(ReadResult);
        write(line1, string'(" LP:"));
        hwrite(line1, LasPwr);
        --write(line1, LasPwr);
        IF BctrStatus(9) = '1' THEN
          write(line1, string'("*"));
        END IF;
      END IF;
      writeline(output, line1);
      IF NWords > 0 THEN
        row_cts := 0;
        while NWords > 0 loop
          IF row_cts = 0 AND BCtrReportCts = '1' THEN
            write(line1, string'("  Ch1:"));
            write(line2, string'("  Ch2:"));
          END IF;
          sbrd(ctr_base+2,'1');
          IF BCtrReportCts = '1' THEN
            write(line1, string'(" "));
            write(line1, to_integer(unsigned(ReadResult)),right,3);
          END IF;
          IF NWords >= 2 THEN
            NWords := NWords - 2;
            sbrd(ctr_base+2,'1');
            IF BCtrReportCts = '1' THEN
              write(line2, string'(" "));
              write(line2, to_integer(unsigned(ReadResult)),right,3);
            END IF;
          ELSE
            NWords := NWords - 1;
            report "Expected even number of words" severity error;
          END IF;
          IF BCtrReportCts = '1' THEN
            IF row_cts >= 29 THEN
              writeline(output, line1);
              writeline(output, line2);
              row_cts := 0;
            ELSE
              row_cts := row_cts + 1;
            END IF;
          END IF;
        end loop;
        IF row_cts > 0 AND BCtrReportCts = '1' THEN
          writeline(output, line1);
          writeline(output, line2);
        END IF;
      END IF;
      return;
    end procedure read_bctr_report;
    
    procedure init_counters IS
      variable my_line : line;
    BEGIN
      CASE BIN_OPT IS
      WHEN 1 =>
        -- Configure for 1 bins of 10
        write(my_line, now,right,12);
        write(my_line, string'(": Using BIN_OPT 1 (1 bin of 10)"));
        writeline(output, my_line);
        sbwr(ctr_base+3, std_logic_vector(to_unsigned(10,16)), '1');
        sbwr(ctr_base+4, std_logic_vector(to_unsigned(1,16)), '1');
        sbrd(ctr_base, '1');
        assert ReadResult = X"0040" report "Expected N_NAB=1 status" severity error;
        -- Now add a second bin of 350ns
        sbwr(ctr_base+5, std_logic_vector(to_unsigned(35,16)), '1');
        sbwr(ctr_base+6, std_logic_vector(to_unsigned(1,16)), '1');
        sbrd(ctr_base, '1');
        assert ReadResult = X"0080" report "Expected N_NAB=2 status" severity error;
        -- And a third bin of 2500ns
        sbwr(ctr_base+7, std_logic_vector(to_unsigned(250,16)), '1');
        sbwr(ctr_base+8, std_logic_vector(to_unsigned(1,16)), '1');
        sbrd(ctr_base, '1');
        assert ReadResult = X"00C0" report "Expecte N_NAB=3 status still" severity error;
      WHEN 2 => -- 75x4, needs to be the bin ctr
        write(my_line, now,right,12);
        write(my_line, string'(": Using BIN_OPT 2 (75 bins of 4)"));
        writeline(output, my_line);
        sbwr(ctr_base+3, std_logic_vector(to_unsigned(4,16)), '1');
        sbwr(ctr_base+4, std_logic_vector(to_unsigned(75,16)), '1');
        -- Check the status again: should be 'Ready' but not enabled
        sbrd(ctr_base, '1');
        assert ReadResult = X"0060" report "Expected N_NAB=1/Ready status" severity error;
      WHEN OTHERS =>
        -- Configure for 45 bins of 1
        write(my_line, now,right,12);
        write(my_line, string'(": Using BIN_OPT 3 (45 bins of 1 and 40 bins of 5)"));
        writeline(output, my_line);
        sbwr(ctr_base+3, std_logic_vector(to_unsigned(1,16)), '1');
        sbwr(ctr_base+4, std_logic_vector(to_unsigned(45,16)), '1');
        -- Check the status again: should be 'Ready' but not enabled
        sbrd(ctr_base, '1');
        assert ReadResult = X"0060" report "Expected N_NAB=1 status" severity error;
        -- 40 bins of 5
        sbwr(ctr_base+5, std_logic_vector(to_unsigned(5,16)), '1');
        sbwr(ctr_base+6, std_logic_vector(to_unsigned(40,16)), '1');
        sbrd(ctr_base, '1');
        assert ReadResult = X"00A0" report "Expected N_NAB=2 status" severity error;
      END CASE;

      sbrd(ctr_base, '1');
      assert ReadResult(5 DOWNTO 0) = "100000" report "Expected Ready status" severity error;
  
      -- Enable and check status
      sbwr(ctr_base, X"0001", '1');
      sbrd(ctr_base, '1');
      assert ReadResult(5 DOWNTO 0) = "100001"
        report "Expected Ready|En status" severity error;
      sbrd(ctr_base+1,'1');
      assert ReadResult = x"0000"
        report "Expected zero FIFO length" severity error;
      return;
    END PROCEDURE init_counters;

    procedure check_chop(online : IN std_logic; offline : IN std_logic; chopping : IN std_logic := '0';
        scanning : IN std_logic := '0') IS
    BEGIN
        IF online = '1' THEN
          assert(BCtrStatus(11) = '1')
            report "Online bit not set" severity error;
        ELSE
          assert(BCtrStatus(11) = '0')
            report "Online bit set erroneously" severity error;
        END IF;
        IF offline = '1' THEN
          assert(BCtrStatus(12) = '1')
            report "Offline bit not set" severity error;
        ELSE
          assert(BCtrStatus(12) = '0')
            report "Offline bit set erroneously" severity error;
        END IF;
        IF chopping = '1' THEN
          assert(BCtrStatus(13) = '1')
            report "Chopping bit not set" severity error;
        ELSE
          assert(BCtrStatus(13) = '0')
            report "Chopping bit set erroneously" severity error;
        END IF;
        IF scanning = '1' THEN
          assert(BCtrStatus(10) = '1')
            report "Scanning bit not set" severity error;
        ELSE
          assert(BCtrStatus(10) = '0')
            report "Scanning bit set erroneously" severity error;
        END IF;
        return;
    END PROCEDURE check_chop;
   
    variable my_line : line;
    variable old_dac_setpoint : unsigned(15 downto 0);
    variable cur_dac_setpoint : unsigned(15 downto 0);
    variable new_dac_setpoint : unsigned(15 downto 0);
  Begin
    SimDone <= '0';
    Addr <= (others => '0');
    ReadResult <= (others => '0');
    BCtrStatus <= (others => '0');
    Data_o <= (others => '0');
    Ctrl <= (others => '0');
    en <= '1';
    RE <= '0';
    rdata <= (others => '0');
    BCtrReportCts <= '1';
    
    CASE BIN_OPT IS
    WHEN 1 =>
        ctr_base <= to_unsigned(16#10#,8);
    WHEN 2 =>
        ctr_base <= to_unsigned(16#20#,8);
    WHEN others =>
        ctr_base <= to_unsigned(16#20#,8);
    END CASE;
    
    -- PMTs <= (others => '0');
    rst <= '1';
    -- pragma synthesis_off
    wait until clk_int'Event and clk_int = '1';
    wait until clk_int'Event and clk_int = '1';
    wait until clk_int'Event and clk_int = '1';
    rst <= '0';
    wait until clk_int'Event and clk_int = '1';
    wait until clk_int'Event and clk_int = '1';

    sbrd(ctr_base, '1');
    assert ReadResult = X"0000" report "Invalid startup status" severity error;

    IF BIN_OPT > 0 AND CTR_OPT = 1 THEN
      write(my_line, now,right,12);
      write(my_line, string'(": Starting BCtr2 tests "));
      writeline(output, my_line);
      init_counters;
      
      for i in 1 to SIM_LOOPS loop
        write(my_line, now,right,12);
        write(my_line, string'(": Starting iteration "));
        write(my_line, i);
        write(my_line, string'(" of "));
        write(my_line, SIM_LOOPS);
        writeline(output, my_line);
        read_bctr_report;
      end loop;

      -- wait for expired status
      write(my_line, now,right,12);
      write(my_line, string'(": Waiting for Expired status"));
      writeline(output, my_line);
      
      read_bctr_report(1,1); -- reports 2
      read_bctr_report(0,2); -- reports 3 that expired
      read_bctr_report(2,2); -- reports 4 that expired
      read_bctr_report(0,1); -- reports 5 
      read_bctr_report(2,2); -- reports 6 as expired
      read_bctr_report(2,2); -- reports 7 as expired
      read_bctr_report(0,1); -- reports 8
      read_bctr_report(3,1); -- reports 11?
      read_bctr_report(0,1);
  
      sbwr(ctr_base, X"0000", '1'); -- Try to disable the counter
      sbrd(ctr_base, '1');
      assert ReadResult(0) = '0' report "Counter not disabled after writing disable" severity error;
      
      sbwr(ctr_base, X"8000", '1'); -- Try reset
      sbrd(ctr_base, '1');
      assert ReadResult = X"0000" report "Counter not reset after reset" severity error;
    END IF; -- BIN_OPT > 0 AND CTR_OPT = 1
    
    -- Temp sensor test
    if TEMP_OPT = '1' then
      write(my_line, now,right,12);
      write(my_line, string'(": Starting Temp Sensor Tests"));
      writeline(output, my_line);
      for i in 1 to 2 loop
        if i > 1 then
          wait for 200 ms;
        end if;
        for sensor in 0 to 5 loop
          sbrd(temp_base + sensor*3,'1');
          check_read(temp_base+sensor*3, X"0000");
          sbrd(temp_base + sensor*3+1,'1');
          check_read(temp_base+sensor*3+1, X"0000");
          sbrd(temp_base + sensor*3+2,'1');
          check_read(temp_base+sensor*3+2, X"0000");
        end loop;
      end loop;
    end if;
    
    if AIO_OPT = '1' THEN
      -- Heater Controller Test
      write(my_line, now,right,12);
      write(my_line, string'(": Starting Heater Controller Tests"));
      writeline(output, my_line);
      sp_updated <= '0';
      sbwr(aio_base+2, X"0000", '0'); -- Should get NACK on write
      -- Check digital commands
      sbrd(aio_base, '1');
      assert ReadResult(5) = '0' AND ReadResult(9) = '0'
        report "Commands are not initialized to zero"
        severity error;
      check_cmds(X"0020");
      check_cmds(X"0000");
      check_cmds(X"0200");
      check_cmds(X"0020");
      check_cmds(X"0000");
      
      
      sbrd(aio_base+1,'1');
      check_read(aio_base+1, X"0000"); -- Verify DAC1 Setpoint init
      write(my_line, now,right,12);
      write(my_line, string'(": sbwr(DAC1)"));
      writeline(output, my_line);
      sbwr(aio_base+1,X"1234",'1');
      sbrd(aio_base+1,'1');
      if ReadResult = X"0000" then
        write(my_line, now,right,12);
        write(my_line, string'(": readback is still zero"));
        writeline(output, my_line);
        while sp_updated = '0' loop
          sbrd(aio_base+1,'1');
          if ReadResult /= X"0000" then
            sp_updated <= '1';
            wait for 10 ns;
          end if;
        end loop;
      end if;
      write(my_line, now,right,12);
      write(my_line, string'(": readback now "));
      hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
      writeline(output, my_line);
      
      wait for 20 ms;
      for i in 1 to 10 loop
        sbrd(aio_base,'1'); -- Status
          write(my_line, now,right,12);
          write(my_line, string'(": Status: "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        sbrd(aio_base+1,'1');
        check_read(aio_base+1, X"0000"); -- DAC1 Setpoint
        sbrd(aio_base+2,'1'); -- DAC1 Readback VSet1
          write(my_line, string'(" VSet1: "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        sbrd(aio_base+3,'1');
        check_read(aio_base+3, X"0000"); -- DAC2 Setpoint
        sbrd(aio_base+4,'1'); -- DAC2 Readback VSet2
          write(my_line, string'(" VSet2: "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        sbrd(aio_base+5,'1'); -- ADC Channel 1 VTemp1
          write(my_line, string'(" VTemp1: "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
        sbrd(aio_base+6,'1'); -- ADC Channel 2 VTemp1
          write(my_line, string'(" VTemp2: "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
          writeline(output, my_line);
        wait for 20 ms;
      end loop;
    end if;
    
    IF DACSCAN_OPT > 0 THEN
      --dacscan tests
      write(my_line, now,right,12);
      write(my_line, string'(": starting dacscan tests"));
      writeline(output, my_line);
      sbwr(x"82", x"0100", '1'); -- scan start
      sbwr(x"83", x"0200", '1'); -- scan stop
      sbwr(x"84", x"0333", '1'); -- scan step * 16 (should be 5 steps)
      sbwr(x"85", X"0173", '1'); -- online pos
      sbwr(x"86", x"FFE0", '1'); -- offline delta -32
      sbwr(x"87", x"0005", '1'); -- dither
      sbwr(x"88", x"0002", '1'); -- 2 points online
      sbwr(x"89", x"0001", '1'); -- 1 point offline
      sbrd(x"81",'1');
      check_read(x"81", x"0000");
      init_counters;
      BCtrReportCts <= '0';
     
      IF DACSCAN_OPT = 1 THEN
      -- Let's try writing a synchronized output
      sp_updated <= '0';
      write(my_line, now,right,12);
      write(my_line, string'(": Setting Setpoint to 0x00FF"));
      writeline(output, my_line);
      sbwr(x"81", x"00FF", '1');
      sbrd(x"81",'1');
      check_read(x"81", x"0000"); -- should still be zero
      old_dac_setpoint := to_unsigned(0,old_dac_setpoint'length);
      new_dac_setpoint := to_unsigned(255,new_dac_setpoint'length);
      sbwr(x"81", x"00FE", '0'); --  Should get no ack now
      while sp_updated = '0' loop
        sbrd(x"81", '1');
        cur_dac_setpoint := unsigned(ReadResult);
        sbrd(ctr_base,'1');
        IF ReadResult(1) = '0' THEN
          assert cur_dac_setpoint = old_dac_setpoint
          report "Setpoint changed early" severity error;
        ELSE
          sp_updated <= '1';
          sbrd(x"81",'1');
          cur_dac_setpoint := unsigned(ReadResult);
          assert cur_dac_setpoint = new_dac_setpoint
          report "Setpoint unchanged after DRdy" severity error;
          write(my_line, now,right,12);
          write(my_line, string'(": readback now "));
          hwrite(my_line, std_logic_vector(ReadResult), RIGHT, 4);
          writeline(output, my_line);
        END IF;
      end loop;
      read_bctr_report;
      
      wait for 500 ns;
      sbrd(x"50",'1');
      sbrd(x"80",'1');
      check_read(x"80", x"0000"); -- zero status, not online, offline or scanning
      sp_updated <= '0';
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing Scan Start Command"));
      writeline(output, my_line);
      sbwr(x"80",x"0001",'1'); -- start scan
      read_bctr_report;
      check_chop('0','0','0','0');
      read_bctr_report;
      check_chop('0','0','0','1');
      
      -- now monitor the loop, reporting steps
      sp_updated <= '0';
 --   Prev_Step <= (others => '0');
      wait until clk'event and clk = '1';
      while sp_updated = '0' loop
        read_bctr_report;
        IF BCtrStatus(10) = '0' THEN
          check_chop('0','0');
          sp_updated <= '1';
          wait until clk'event and clk = '1';
        ELSE
          check_chop('0','0','0','1');
        END IF;
      end loop;
      write(my_line, now,right,12);
      write(my_line, string'(": Scan Stopped, testing online/offline"));
      writeline(output, my_line);
  
      sp_updated <= '0';
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing Drive Online"));
      writeline(output, my_line);
      sbwr(x"80", x"0002",'1'); -- Drive online
      read_bctr_report;
      check_chop('0','0');
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing Drive Offline"));
      writeline(output, my_line);
      sbwr(x"80", x"0005",'1'); -- Drive offline
      read_bctr_report; -- Now we should be reporting online
      check_chop('1','0');
      read_bctr_report; -- Now we should be reporting offline
      check_chop('0','1');
      END IF; -- DACSCAN_OPT = 1

      IF DACSCAN_OPT < 3 THEN
      -- Test chop mode start and stop
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing chop mode start"));
      writeline(output, my_line);
      sbwr(x"80", x"0006",'1'); -- Enter Chop Mode (online)
      read_bctr_report;
      IF DACSCAN_OPT > 1 THEN
        check_chop('0','0');
      ELSE
        check_chop('0','1'); -- Not chopping yet
      END IF;
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      read_bctr_report;
      check_chop('0','1','1'); -- Offline (and chopping)
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing chop mode stop"));
      writeline(output, my_line);
      sbwr(x"80", x"0007",'1'); -- Exit Chop Mode (after offline)
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      read_bctr_report;
      check_chop('0','1','1'); -- Offline (and chopping)
      read_bctr_report;
      check_chop('0','1','0'); -- Offline (and not chopping)
      read_bctr_report;
      check_chop('0','1','0'); -- Offline (and not chopping)
      END IF; -- DACSCAN_OPT < 3

      write(my_line, now,right,12);
      write(my_line, string'(": Issuing chop mode start"));
      writeline(output, my_line);
      sbwr(x"80", x"0006",'1'); -- Enter Chop Mode (online)
      read_bctr_report;
      IF DACSCAN_OPT < 3 THEN
        check_chop('0','1');
      ELSE
        check_chop('0','0'); -- Not chopping yet
      END IF;
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      write(my_line, now,right,12);
      write(my_line, string'(": Issuing scan start (after offline)"));
      writeline(output, my_line);
      sbwr(x"80", x"0001",'1'); -- Start scan after Offline
      read_bctr_report;
      check_chop('1','0','1'); -- Online (and chopping)
      read_bctr_report;
      check_chop('0','1','1'); -- Offline (and chopping)
      read_bctr_report;
      check_chop('0','0','0','1');
      
      sp_updated <= '0';
      wait until clk'event and clk = '1';
      while sp_updated = '0' loop
        read_bctr_report;
        IF BCtrStatus(10) = '0' THEN
          check_chop('0','0');
          sp_updated <= '1';
          wait until clk'event and clk = '1';
        ELSE
          check_chop('0','0','0','1');
        END IF;
      end loop;
      write(my_line, now,right,12);
      write(my_line, string'(": Scan Complete: End of DACscan tests"));
      writeline(output, my_line);
      
    END IF; -- DACSCAN_OPT = '1'
    
    SimDone <= '1';
    wait;
   -- pragma synthesis_on
  END PROCESS;
END ARCHITECTURE rtl;

--
-- VHDL Test Bench BCtr_lib.BCtr_sys_tb1.BCtr_sys_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 14:57:52 01/11/2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;


ENTITY BCtr_sys_tb1 IS
  GENERIC (
    ADDR_WIDTH      : integer range 16 downto 8 := 8;
    N_CHANNELS      : integer range 4 downto 1  := 1;
    CTR_WIDTH       : integer range 32 downto 1 := 16;
    FIFO_ADDR_WIDTH : integer range 10 downto 4 := 9;
    N_BOARDS        : integer range 10 downto 1 := 1;
    FAIL_WIDTH      : integer range 16 downto 0 := 2;
    SW_WIDTH        : integer range 16 downto 0 := 0;
    N_INTERRUPTS    : integer range 16 downto 0 := 0
  );
END ENTITY BCtr_sys_tb1;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
LIBRARY BCtr_lib;
USE BCtr_lib.ALL;


ARCHITECTURE rtl OF BCtr_sys_tb1 IS

  -- Architecture declarations

  -- Internal signal declarations
  SIGNAL Addr          : std_logic_vector(ADDR_WIDTH-1 DOWNTO 0);
  SIGNAL clk           : std_logic;
  SIGNAL Ctrl          : std_logic_vector(6 DOWNTO 0);
  SIGNAL Data_i        : std_logic_vector(15 DOWNTO 0);
  SIGNAL Data_o        : std_logic_vector(15 DOWNTO 0);
  SIGNAL Fail_Out      : std_logic_vector(FAIL_WIDTH-1 DOWNTO 0);
  SIGNAL Flt_CPU_Reset : std_logic;
  SIGNAL PMTs          : std_logic_vector(N_CHANNELS-1 DOWNTO 0);
  SIGNAL Status        : std_logic_vector(3 DOWNTO 0);
  SIGNAL Switches      : std_logic_vector(SW_WIDTH-1 DOWNTO 0);
  SIGNAL Trigger       : std_logic;
  SIGNAL SimDone       : std_logic;
  alias RdEn is Ctrl(0);
  alias WrEn is Ctrl(1);
  alias CS is Ctrl(2);
  alias CE is Ctrl(3);
  alias rst is Ctrl(4);
  alias arm is Ctrl(6);
  alias TickTock is Ctrl(5);
  alias Done is Status(0);
  alias Ack is Status(1);
  alias ExpIntr is Status(2);
  alias TwoSecondTO is Status(3);
  SIGNAL ReadResult : std_logic_vector(15 DOWNTO 0);
  SIGNAL NA, NB, NC : unsigned(15 DOWNTO 0);


  -- Component declarations
  COMPONENT BCtr_sys
    GENERIC (
      ADDR_WIDTH      : integer range 16 downto 8 := 8;
      N_CHANNELS      : integer range 4 downto 1  := 1;
      CTR_WIDTH       : integer range 32 downto 1 := 16;
      FIFO_ADDR_WIDTH : integer range 10 downto 4 := 9;
      N_BOARDS        : integer range 10 downto 1 := 1;
      FAIL_WIDTH      : integer range 16 downto 0 := 2;
      SW_WIDTH        : integer range 16 downto 0 := 1;
      N_INTERRUPTS    : integer range 16 downto 0 := 1
    );
    PORT (
      Addr          : IN     std_logic_vector(ADDR_WIDTH-1 DOWNTO 0);
      clk           : IN     std_logic;
      Ctrl          : IN     std_logic_vector(6 DOWNTO 0);
      Data_i        : OUT    std_logic_vector(15 DOWNTO 0);
      Data_o        : IN     std_logic_vector(15 DOWNTO 0);
      Fail_Out      : OUT    std_logic_vector(FAIL_WIDTH-1 DOWNTO 0);
      Flt_CPU_Reset : OUT    std_logic;
      PMTs          : IN     std_logic_vector(N_CHANNELS-1 DOWNTO 0);
      Status        : OUT    std_logic_vector(3 DOWNTO 0);
      Switches      : IN     std_logic_vector(SW_WIDTH-1 DOWNTO 0);
      Trigger       : IN     std_logic
    );
  END COMPONENT BCtr_sys;

  -- embedded configurations
  -- pragma synthesis_off
  FOR U_0 : BCtr_sys USE ENTITY BCtr_lib.BCtr_sys;
  -- pragma synthesis_on

BEGIN

    U_0 : BCtr_sys
      GENERIC MAP (
        ADDR_WIDTH      => ADDR_WIDTH,
        N_CHANNELS      => N_CHANNELS,
        CTR_WIDTH       => CTR_WIDTH,
        FIFO_ADDR_WIDTH => FIFO_ADDR_WIDTH,
        N_BOARDS        => N_BOARDS,
        FAIL_WIDTH      => FAIL_WIDTH,
        SW_WIDTH        => SW_WIDTH,
        N_INTERRUPTS    => N_INTERRUPTS
      )
      PORT MAP (
        Addr          => Addr,
        clk           => clk,
        Ctrl          => Ctrl,
        Data_i        => Data_i,
        Data_o        => Data_o,
        Fail_Out      => Fail_Out,
        Flt_CPU_Reset => Flt_CPU_Reset,
        PMTs          => PMTs,
        Status        => Status,
        Switches      => Switches,
        Trigger       => Trigger
      );

      
  f100m_clk : Process is
  Begin
    clk <= '0';
    -- pragma synthesis_off
    wait for 20 ns;
    while SimDone = '0' loop
      clk <= '1';
      PMTs(0) <= '0';
      wait for 5 ns;
      clk <= '0';
      PMTs(0) <= '1';
      wait for 5 ns;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;
  
  trig_proc: Process is
  Begin
    Trigger <= '0';
    -- pragma synthesis_off
    wait for 200 ns;
    while SimDone = '0' loop
      wait until clk'Event AND clk = '1';
      wait for 3 ns;
      Trigger <= '1';
      wait for 5 ns;
      Trigger <= '0';
      for i in 1 to (to_integer(NA)+1)*(to_integer(NB)+1)+3 loop
        wait until clk'Event AND clk = '1';
      end loop;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process trig_proc;

  test_proc: Process is
    procedure sbwr(
        addr_in : IN std_logic_vector(ADDR_WIDTH-1 DOWNTO 0);
        data : IN std_logic_vector(15 DOWNTO 0);
        AckExpected : std_logic ) is
    begin
      Addr <= addr_in(ADDR_WIDTH-1 DOWNTO 0);
      Data_o <= data;
      -- pragma synthesis_off
      wait until clk'EVENT AND clk = '1';
      WrEn <= '1';
      for i in 1 to 8 loop
        wait until clk'EVENT AND clk = '1';
      end loop;
      if AckExpected = '1' then
        assert Ack = '1' report "Expected Ack" severity error;
      else
        assert Ack = '0' report "Expected no Ack" severity error;
      end if;
      WrEn <= '0';
      wait until clk'EVENT AND clk = '1';
      -- pragma synthesis_on
      return;
    end procedure sbwr;

    procedure sbrd( addr_in : std_logic_vector (ADDR_WIDTH-1 DOWNTO 0);
                    AckExpected : std_logic ) is
    begin
      Addr <= addr_in;
      -- pragma synthesis_off
      wait until clk'Event AND clk = '1';
      wait for 1 ns;
      RdEn <= '1';
      for i in 1 to 8 loop
        wait until clk'Event AND clk = '1';
      end loop;
      if AckExpected = '1' then
        assert Ack = '1' report "Expected Ack on read" severity error;
      else
        assert Ack = '0' report "Expected no Ack on read" severity error;
      end if;
      ReadResult <= Data_i;
      RdEn <= '0';
      wait for 125 ns;
      -- pragma synthesis_on
      return;
    end procedure sbrd;
    
    procedure wait_for_triggers(N : integer) is
      variable delay : integer := (to_integer(NA)+1)*(to_integer(NB)+1)+7;
    begin
      for i in 1 to N loop
        -- pragma synthesis_off
        wait until Trigger = '1' for delay*10 ns;
        assert Trigger = '1' report "Expected Trigger" severity error;
        wait until Trigger = '0' for delay*10 ns;
        -- pragma synthesis_on
        assert Trigger = '0' report "Expected Trigger to clear" severity error;
      end loop;
      return;
    end procedure wait_for_triggers;
    
    procedure test1(
       A : std_logic_vector(15 downto 0);
       B : std_logic_vector(15 downto 0);
       C : std_logic_vector(15 downto 0)) is
      VARIABLE NW : unsigned(15 DOWNTO 0);
    begin
      NA <= unsigned(A);
      NB <= unsigned(B);
      NC <= unsigned(C);
      -- pragma synthesis_off
      sbwr(X"10",X"8000",'1');
      sbrd( X"10", '1');
      assert ReadResult = X"0000" report "Expected startup status after reset"
        severity error;
      sbwr(X"13",std_logic_vector(NA),'1');
      sbwr(X"14",std_logic_vector(NB),'1');
      sbwr(X"1B",std_logic_vector(NC),'1');
      sbrd(X"10", '1');
      assert ReadResult = X"0020" report "Expected Ready" severity error;
      sbwr(X"10", X"0001", '1');
      sbrd(X"10", '1');
      assert ReadResult = X"0021" report "Expected Ready|En" severity error;
      wait_for_triggers(to_integer(NC)+2);
      sbrd( X"10", '1');
      assert ReadResult = X"0023" report "Expected Ready|DRdy|En" severity error;
      sbrd( X"11", '1');
      NW := unsigned(ReadResult);
      assert NW = NB+1 report "Expected Word count to be NB+1" severity error;
      while NW > 0 loop
        sbrd(X"12", '1');
        NW := NW-1;
      end loop;
      sbrd( X"10", '1');

      -- pragma synthesis_on
      return;
    end procedure test1;
  Begin
    SimDone <= '0';
    Addr <= (others => '0');
    ReadResult <= (others => '0');
    Data_o <= (others => '0');
    Ctrl <= (others => '0');
    NA <= to_unsigned(4,16);
    NB <= to_unsigned(3,16);
    -- PMTs <= (others => '0');
    rst <= '1';
    -- pragma synthesis_off
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    rst <= '0';
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';

    -- Check NACK
    sbrd( std_logic_vector(to_unsigned(0,ADDR_WIDTH)), '0');
    -- Read baseline status:
    sbrd( X"10", '1');
    assert ReadResult = X"0000" report "Invalid startup status" severity error;
    -- Configure for 3 bins of 4
    sbwr( X"13", std_logic_vector(NA), '1');
    sbwr( X"14", std_logic_vector(NB), '1');
    -- Check the status again: should be 'Ready' but not enabled
    sbrd( X"10", '1');
    assert ReadResult = X"0020" report "Expected Ready status" severity error;
    -- Enable and check status
    sbwr( X"10", X"0001", '1');
    sbrd( X"10", '1');
    assert ReadResult = X"0021" report "Expected Ready|En status" severity error;
    
    -- Now reset and check status
    sbwr( X"10", X"8000", '1');
    sbrd( X"10", '1');
    assert ReadResult = X"0000" report "Expected startup status after reset" severity error;
    
    Test1(X"0004", X"0002", X"0001");
    Test1(X"0001", X"0007", X"0005");
    Test1(X"0030", X"0002", X"0010");
    
    SimDone <= '1';
    wait;
   -- pragma synthesis_on
  END PROCESS;

END ARCHITECTURE rtl;
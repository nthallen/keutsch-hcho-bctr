--
-- VHDL Test Bench BCtr_lib.pps_sbbd_tb.pps_sbbd_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 11:56:16 10/26/2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
USE std.textio.all;


ENTITY pps_sbbd_tb IS
  GENERIC (
    ADDR_WIDTH : integer range 16 downto 8 := 8;
    BASE_ADDR  : unsigned(15 downto 0)     := x"0060";
    CLK_FREQ : unsigned(31 downto 0) := to_unsigned(100000,32);
    MSW_SHIFT : integer range 16 downto 0  := 1
  );
END ENTITY pps_sbbd_tb;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
LIBRARY BCtr_lib;
USE BCtr_lib.ALL;


ARCHITECTURE rtl OF pps_sbbd_tb IS

  -- Architecture declarations

  -- Internal signal declarations
  SIGNAL clk      : std_logic;
  SIGNAL ExpAck   : std_logic;
  SIGNAL ExpAddr  : std_logic_vector(ADDR_WIDTH-1 DOWNTO 0);
  SIGNAL ExpRd    : std_logic;
  SIGNAL ExpReset : std_logic;
  SIGNAL ExpWr    : std_logic;
  SIGNAL PPS      : std_logic;
  SIGNAL RData    : std_logic_vector(15 DOWNTO 0);
  SIGNAL WData    : std_logic_vector(15 DOWNTO 0);
  SIGNAL ReadData : std_logic_vector(15 DOWNTO 0);
  SIGNAL SimDone  : std_logic;


  -- Component declarations
  COMPONENT pps_sbbd
    GENERIC (
      ADDR_WIDTH : integer range 16 downto 8 := 8;
      BASE_ADDR  : unsigned(15 downto 0)     := x"0060";
      CLK_FREQ : unsigned(31 DOWNTO 0) := to_unsigned(100000000,32);
      MSW_SHIFT : integer range 16 downto 0 := 11
    );
    PORT (
      clk      : IN     std_logic;
      ExpAck   : OUT    std_logic;
      ExpAddr  : IN     std_logic_vector(ADDR_WIDTH-1 DOWNTO 0);
      ExpRd    : IN     std_logic;
      ExpReset : IN     std_logic;
      ExpWr    : IN     std_logic;
      PPS      : OUT    std_logic;
      RData    : OUT    std_logic_vector(15 DOWNTO 0);
      WData    : IN     std_logic_vector(15 DOWNTO 0)
    );
  END COMPONENT pps_sbbd;

  -- embedded configurations
  -- pragma synthesis_off
  FOR dut_pps_sbbd : pps_sbbd USE ENTITY BCtr_lib.pps_sbbd;
  -- pragma synthesis_on

BEGIN

  dut_pps_sbbd : pps_sbbd
    GENERIC MAP (
      ADDR_WIDTH => ADDR_WIDTH,
      BASE_ADDR  => BASE_ADDR,
      CLK_FREQ   => CLK_FREQ,
      MSW_SHIFT  => MSW_SHIFT
    )
    PORT MAP (
      clk      => clk,
      ExpAck   => ExpAck,
      ExpAddr  => ExpAddr,
      ExpRd    => ExpRd,
      ExpReset => ExpReset,
      ExpWr    => ExpWr,
      PPS      => PPS,
      RData    => RData,
      WData    => WData
    );

  f100k_clk : Process is
  Begin
    clk <= '0';
    -- pragma synthesis_off
    wait for 20 ns;
    while SimDone = '0' loop
      clk <= '1';
      wait for 5 us;
      clk <= '0';
      wait for 5 us;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;

  test_proc: Process is
    procedure sbwr(
        addr : IN std_logic_vector(15 DOWNTO 0);
        data : IN std_logic_vector(15 DOWNTO 0);
        AckExpected : std_logic ) is
    begin
      ExpAddr <= addr(ADDR_WIDTH-1 DOWNTO 0);
      WData <= data;
      -- pragma synthesis_off
      wait until clk'EVENT AND clk = '1';
      ExpWr <= '1';
      for i in 1 to 8 loop
        wait until clk'EVENT AND clk = '1';
      end loop;
      if AckExpected = '1' then
        assert ExpAck = '1' report "Expected Ack" severity error;
      else
        assert ExpAck = '0' report "Expected no Ack" severity error;
      end if;
      ExpWr <= '0';
      wait until clk'EVENT AND clk = '1';
      -- pragma synthesis_on
      return;
    end procedure sbwr;

    procedure sbrd(
        addr : IN std_logic_vector(15 DOWNTO 0) ) is
    begin
      ExpAddr <= addr(ADDR_WIDTH-1 DOWNTO 0);
      -- pragma synthesis_off
      wait until clk'EVENT AND clk = '1';
      ExpRd <= '1';
      for i in 1 to 8 loop
        wait until clk'EVENT AND clk = '1';
      end loop;
      assert ExpAck = '1' report "Expected Ack on sbrd" severity error;
      ReadData <= RData;
      ExpRd <= '0';
      wait until clk'EVENT AND clk = '1';
      -- pragma synthesis_on
      return;
    end procedure sbrd;
    
    procedure rpt_MSW is
      variable my_line : line;
    begin
      sbrd(x"0060");
      write(my_line, now);
      write(my_line, string'(": MSW "));
      write(my_line, to_integer(unsigned(ReadData)));
      writeline(output, my_line);
    end procedure rpt_MSW;
    
    procedure rpt_fine is
      variable my_line : line;
    begin
      sbrd(x"0061");
      write(my_line, now);
      write(my_line, string'(": Fine "));
      write(my_line, to_integer(unsigned(ReadData)));
      writeline(output, my_line);
    end procedure rpt_fine;
    
    variable my_line : line;
    variable toff : std_logic_vector(31 downto 0);
  Begin
    SimDone <= '0';
    WData <= (others => '0');
    ExpAddr <= (others => '0');
    ExpRd <= '0';
    ExpWr <= '0';
    ExpReset <= '1';
    -- pragma synthesis_off
    -- might need to reset the circuit here...
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';
    ExpReset <= '0';
    
    for i in 1 to 9 loop
      wait for 100 ms;
      rpt_MSW;
    end loop;
    wait until PPS = '1';
    rpt_MSW;
    toff := std_logic_vector(to_unsigned(75000,32));
    sbwr(x"0064", toff(15 downto 0),'1');
    sbwr(x"0065", toff(31 downto 16),'1');
    write(my_line, now);
    write(my_line, string'(": Writing offset of "));
    write(my_line, to_integer(unsigned(toff)));
    writeline(output, my_line);
    for i in 1 to 4 loop
      rpt_MSW;
      wait for 100 ms;
    end loop;
    rpt_fine;
    sbwr(x"0061", std_logic_vector(to_signed(2000,16)),'1');
    rpt_fine;
    wait for 10 ms;
    rpt_fine;
    
    wait until clk'Event and clk = '1';
    wait until clk'Event and clk = '1';

    SimDone <= '1';
    wait;
   -- pragma synthesis_on
  END PROCESS;

END ARCHITECTURE rtl;